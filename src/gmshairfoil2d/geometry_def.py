from operator import attrgetter
import gmsh
import numpy as np
import math



"""
This script contain the definition of geometrical objects needed to build
the geometry and latter the mesh
"""


class Point:
    def __init__(self, x, y, z, mesh_size):
        # position in space
        self.x = x
        self.y = y
        self.z = z
        self.mesh_size = mesh_size
        self.dim = 0
        # create the gmsh object and store the tag of the geometric object
        self.tag = gmsh.model.occ.addPoint(self.x, self.y, self.z, self.mesh_size)


class Line:
    def __init__(self, start_point, end_point):
        # tag of the two points forming the line
        self.start_point = start_point
        self.end_point = end_point
        self.dim = 1
        # create the gmsh object and store the tag of the geometric object
        self.tag = gmsh.model.occ.addLine(self.start_point.tag, self.end_point.tag)


class CurveLoop:
    def __init__(self, line_list):
        # Line list must be in the order of the wanted CurveLoop and closed
        self.line_list = line_list
        self.tag_list = []
        # generate the Lines tag list to folow
        self.tag_list = [line.tag for line in self.line_list]
        # create the gmsh object and store the tag of the geometric object
        self.tag = gmsh.model.occ.addCurveLoop(self.tag_list)


class Circle:
    def __init__(self, xc, yc, zc, radius, mesh_size):
        # Position of the disk center
        self.xc = xc
        self.yc = yc
        self.zc = zc
        self.radius = radius
        self.mesh_size = mesh_size
        self.dim = 1
        # create a structured arcCricle to merge in one curveloop
        self.distribution = math.floor((np.pi * 2 * self.radius) / self.mesh_size)
        self.arcCircle_list = [
            gmsh.model.occ.addCircle(
                self.xc,
                self.yc,
                self.zc,
                self.radius,
                angle1=2 * np.pi / self.distribution * i,
                angle2=2 * np.pi / self.distribution * (1 + i),
            )
            for i in range(0, self.distribution)
        ]
        gmsh.model.occ.synchronize()
        gmsh.model.occ.removeAllDuplicates()
        self.tag = gmsh.model.occ.addCurveLoop(self.arcCircle_list)
        # remove double points generated by the arcCurve
        # Define BC
        gmsh.model.occ.synchronize()
        self.bc = gmsh.model.addPhysicalGroup(self.dim, self.arcCircle_list)
        self.physical_name = gmsh.model.setPhysicalName(self.dim, self.bc, "farfield")


class Rectangle:
    def __init__(self, xc, yc, z, dx, dy, mesh_size):
        self.xc = xc
        self.yc = yc
        self.z = z
        self.dx = dx
        self.dy = dy
        self.mesh_size = mesh_size
        self.dim = 1
        # generate 4 points, 4 lines
        self.points = [
            Point(self.xc - self.dx / 2, self.yc - self.dy / 2, z, self.mesh_size),
            Point(self.xc + self.dx / 2, self.yc - self.dy / 2, z, self.mesh_size),
            Point(self.xc + self.dx / 2, self.yc + self.dy / 2, z, self.mesh_size),
            Point(self.xc - self.dx / 2, self.yc + self.dy / 2, z, self.mesh_size),
        ]
        self.lines = [
            Line(self.points[0], self.points[1]),
            Line(self.points[1], self.points[2]),
            Line(self.points[2], self.points[3]),
            Line(self.points[3], self.points[0]),
        ]
        # Create the corresponding curveloop
        self.tag = CurveLoop(self.lines).tag

        # Define BC
        self.wall_bot = self.lines[0]
        self.outlet = self.lines[1]
        self.wall_top = self.lines[2]
        self.inlet = self.lines[3]

        gmsh.model.occ.synchronize()
        self.bc_in = gmsh.model.addPhysicalGroup(self.dim, [self.inlet.tag], tag=-1)
        gmsh.model.setPhysicalName(self.dim, self.bc_in, "inlet")

        self.bc_out = gmsh.model.addPhysicalGroup(self.dim, [self.outlet.tag])
        gmsh.model.setPhysicalName(self.dim, self.bc_out, "outlet")

        self.bc_wall = gmsh.model.addPhysicalGroup(
            self.dim, [self.wall_bot.tag, self.wall_top.tag]
        )
        gmsh.model.setPhysicalName(self.dim, self.bc_wall, "wall")
        self.bc = [self.bc_in, self.bc_out, self.bc_wall]


class PlaneSurface:
    """
    A plane surface defined by one or more curve loops tags
    The first curve loop defines the exterior contour; additional curve loop
    define holes in the surface domaine
    """

    def __init__(self, curveLoop_list):
        self.curveLoop_list = curveLoop_list
        self.tag_list = [curveLoop.tag for curveLoop in self.curveLoop_list]
        self.dim = 2
        # create the gmsh object and store the tag of the geometric object
        self.tag = gmsh.model.occ.addPlaneSurface(self.tag_list)

        # Define BC
        gmsh.model.occ.synchronize()
        self.ps = gmsh.model.addPhysicalGroup(self.dim, [self.tag])
        gmsh.model.setPhysicalName(self.dim, self.ps, "fluid")


class Airfoil:
    """
    Generate an CurveLoop formed with the cloud of points
    representing the airfoil. Note that a Mesh size larger
    than the resolution given by the cloud of points
    will not be taken into account
    """

    def __init__(self, point_cloud, mesh_size, name="airfoil"):
        self.name = name
        self.dim = 1
        # Generate Points object from the point_cloud
        self.points = [
            Point(point_cord[0], point_cord[1], point_cord[2], mesh_size)
            for point_cord in point_cloud
        ]

        self.lines = [
            Line(self.points[i], self.points[i + 1])
            for i in range(-1, len(self.points) - 1)
        ]

        self.CurveLoop = CurveLoop(self.lines)
        self.tag = self.CurveLoop.tag
        # Define BC
        gmsh.model.occ.synchronize()
        self.bc = gmsh.model.addPhysicalGroup(self.dim, self.CurveLoop.tag_list)
        gmsh.model.setPhysicalName(self.dim, self.bc, self.name)


class AirfoilSpline:
    """
    Constructing the foil using Spline which result in
    a better meshing possibility when the foil consist
    of only few points
    """

    def __init__(self, point_cloud, mesh_size, name="airfoil"):
        self.name = name
        self.dim = 1
        # Generate Points object from the point_cloud
        self.points = [
            Point(point_cord[0], point_cord[1], point_cord[2], mesh_size)
            for point_cord in point_cloud
        ]
        self.le = min(self.points, key=attrgetter("x"))
        self.te = max(self.points, key=attrgetter("x"))
        self.points_tag = [point.tag for point in self.points]
        if self.le.tag < self.te.tag:
            # create a spline from the leading edge to the trailing edge
            self.upper_spline_tag = gmsh.model.occ.addSpline(
                self.points_tag[
                    self.points_tag.index(self.le.tag) : self.points_tag.index(
                        self.te.tag
                    )
                    + 1
                ]
            )
            # create a spline from the trailing edge to the leading edge
            self.lower_spline_tag = gmsh.model.occ.addSpline(
                self.points_tag[
                    self.points_tag.index(self.te.tag) : self.points_tag[-1]
                ]
                + self.points_tag[0 : self.points_tag.index(self.le.tag) + 1]
            )

        else:
            self.upper_spline_tag = gmsh.model.occ.addSpline(
                (
                    self.points_tag[
                        (self.points_tag).index(self.le.tag) : (self.points_tag[-1])
                    ]
                    + self.points_tag[0 : self.points_tag.index(self.te.tag) + 1]
                )
            )
            self.lower_spline_tag = gmsh.model.occ.addSpline(
                self.points_tag[
                    self.points_tag.index(self.te.tag) : self.points_tag.index(
                        self.le.tag
                    )
                    + 1
                ]
            )
        # form the curvedloop
        self.tag = gmsh.model.occ.addCurveLoop(
            [self.upper_spline_tag, self.lower_spline_tag]
        )

        # Define BC
        gmsh.model.occ.synchronize()
        self.bc = gmsh.model.addPhysicalGroup(
            self.dim, [self.upper_spline_tag, self.lower_spline_tag]
        )
        gmsh.model.setPhysicalName(self.dim, self.bc, self.name)